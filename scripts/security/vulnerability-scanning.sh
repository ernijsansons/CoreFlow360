#!/bin/bash

# CoreFlow360 - Local Vulnerability Scanning Script
# This script provides comprehensive security scanning for local development

set -euo pipefail

# Configuration
SCAN_TYPE="${1:-all}"
OUTPUT_DIR="${OUTPUT_DIR:-./security-reports}"
VERBOSE="${VERBOSE:-false}"
FAIL_ON_HIGH="${FAIL_ON_HIGH:-true}"
CONTAINER_IMAGE="${CONTAINER_IMAGE:-coreflow360/consciousness:latest}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_security() {
    echo -e "${PURPLE}[SECURITY]${NC} $1"
}

log_scan() {
    echo -e "${CYAN}[SCAN]${NC} $1"
}

# Function to check if tool is installed
check_tool() {
    local tool="$1"
    local install_cmd="$2"
    
    if ! command -v "$tool" &> /dev/null; then
        log_warning "$tool is not installed"
        log_info "Install with: $install_cmd"
        return 1
    fi
    return 0
}

# Function to setup output directory
setup_output_dir() {
    mkdir -p "$OUTPUT_DIR"
    log_info "Security reports will be saved to: $OUTPUT_DIR"
}

# Function to scan dependencies
scan_dependencies() {
    log_scan "Starting dependency vulnerability scan..."
    
    # NPM Audit
    log_info "Running npm audit..."
    if npm audit --audit-level=moderate --json > "$OUTPUT_DIR/npm-audit.json" 2>/dev/null; then
        log_success "npm audit completed - no high/critical issues found"
    else
        log_warning "npm audit found vulnerabilities - check $OUTPUT_DIR/npm-audit.json"
    fi
    
    # Generate human-readable npm audit report
    npm audit --audit-level=moderate > "$OUTPUT_DIR/npm-audit.txt" 2>/dev/null || true
    
    # Snyk scan (if available)
    if check_tool "snyk" "npm install -g snyk"; then
        log_info "Running Snyk dependency scan..."
        if snyk test --json > "$OUTPUT_DIR/snyk-dependencies.json" 2>/dev/null; then
            log_success "Snyk dependency scan completed - no issues found"
        else
            log_warning "Snyk found dependency vulnerabilities - check $OUTPUT_DIR/snyk-dependencies.json"
        fi
        
        # Generate human-readable Snyk report
        snyk test > "$OUTPUT_DIR/snyk-dependencies.txt" 2>/dev/null || true
    fi
    
    # OSV Scanner (if available)
    if check_tool "osv-scanner" "go install github.com/google/osv-scanner/cmd/osv-scanner@v1"; then
        log_info "Running OSV vulnerability scan..."
        if osv-scanner --json --format json --output "$OUTPUT_DIR/osv-scan.json" . > /dev/null 2>&1; then
            log_success "OSV scan completed"
        else
            log_warning "OSV scan found vulnerabilities - check $OUTPUT_DIR/osv-scan.json"
        fi
    fi
    
    log_success "Dependency scan completed"
}

# Function to scan for secrets
scan_secrets() {
    log_scan "Starting secret detection scan..."
    
    # TruffleHog (if available)
    if check_tool "trufflehog" "curl -sSfL https://raw.githubusercontent.com/trufflesecurity/trufflehog/main/scripts/install.sh | sh -s -- -b /usr/local/bin"; then
        log_info "Running TruffleHog secret scan..."
        if trufflehog filesystem . --json > "$OUTPUT_DIR/trufflehog-secrets.json" 2>/dev/null; then
            log_success "TruffleHog scan completed - no secrets found"
        else
            log_warning "TruffleHog found potential secrets - check $OUTPUT_DIR/trufflehog-secrets.json"
        fi
    fi
    
    # GitLeaks (if available)
    if check_tool "gitleaks" "brew install gitleaks"; then
        log_info "Running GitLeaks secret scan..."
        if gitleaks detect --source . --report-path "$OUTPUT_DIR/gitleaks-secrets.json" --report-format json > /dev/null 2>&1; then
            log_success "GitLeaks scan completed - no secrets found"
        else
            log_warning "GitLeaks found potential secrets - check $OUTPUT_DIR/gitleaks-secrets.json"
        fi
    fi
    
    # Manual secret patterns check
    log_info "Running manual secret pattern detection..."
    cat > "$OUTPUT_DIR/secret-patterns.txt" << 'EOF'
# Manual Secret Pattern Detection Results

## Checking for common secret patterns...

EOF
    
    # Check for common secret patterns
    local patterns=(
        "password.*=.*['\"][^'\"]{8,}['\"]"
        "secret.*=.*['\"][^'\"]{16,}['\"]"
        "key.*=.*['\"][^'\"]{16,}['\"]"
        "token.*=.*['\"][^'\"]{20,}['\"]"
        "sk-[a-zA-Z0-9]{20,}"
        "pk_[a-zA-Z0-9]{20,}"
        "whsec_[a-zA-Z0-9]{20,}"
        "AKIA[0-9A-Z]{16}"
        "-----BEGIN.*PRIVATE KEY-----"
    )
    
    local found_secrets=false
    for pattern in "${patterns[@]}"; do
        if grep -r -E "$pattern" --include="*.ts" --include="*.js" --include="*.tsx" --include="*.jsx" --include="*.json" --include="*.yml" --include="*.yaml" --exclude-dir=node_modules --exclude-dir=.git . >> "$OUTPUT_DIR/secret-patterns.txt" 2>/dev/null; then
            found_secrets=true
        fi
    done
    
    if [ "$found_secrets" = true ]; then
        log_warning "Found potential secret patterns - check $OUTPUT_DIR/secret-patterns.txt"
    else
        echo "No secret patterns found." >> "$OUTPUT_DIR/secret-patterns.txt"
        log_success "No secret patterns detected"
    fi
    
    log_success "Secret scan completed"
}

# Function to scan containers
scan_containers() {
    log_scan "Starting container vulnerability scan..."
    
    # Check if Docker is available
    if ! check_tool "docker" "Install Docker Desktop"; then
        log_error "Docker is required for container scanning"
        return 1
    fi
    
    # Build image if it doesn't exist
    if ! docker image inspect "$CONTAINER_IMAGE" > /dev/null 2>&1; then
        log_info "Building container image for scanning..."
        docker build -t "$CONTAINER_IMAGE" .
    fi
    
    # Trivy container scan (if available)
    if check_tool "trivy" "curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin"; then
        log_info "Running Trivy container scan..."
        
        # Update Trivy database
        trivy image --download-db-only > /dev/null 2>&1 || true
        
        # Run vulnerability scan
        trivy image --format json --output "$OUTPUT_DIR/trivy-container.json" "$CONTAINER_IMAGE" > /dev/null 2>&1 || true
        trivy image --format table --output "$OUTPUT_DIR/trivy-container.txt" "$CONTAINER_IMAGE" 2>/dev/null || true
        
        # Check for critical/high vulnerabilities
        local critical_count=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL") | .VulnerabilityID' "$OUTPUT_DIR/trivy-container.json" 2>/dev/null | wc -l || echo "0")
        local high_count=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH") | .VulnerabilityID' "$OUTPUT_DIR/trivy-container.json" 2>/dev/null | wc -l || echo "0")
        
        if [ "$critical_count" -gt 0 ] || [ "$high_count" -gt 0 ]; then
            log_warning "Found $critical_count critical and $high_count high severity vulnerabilities"
        else
            log_success "No critical or high severity vulnerabilities found"
        fi
    fi
    
    # Grype container scan (if available)
    if check_tool "grype" "curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin"; then
        log_info "Running Grype container scan..."
        grype "$CONTAINER_IMAGE" -o json > "$OUTPUT_DIR/grype-container.json" 2>/dev/null || true
        grype "$CONTAINER_IMAGE" -o table > "$OUTPUT_DIR/grype-container.txt" 2>/dev/null || true
    fi
    
    # Docker Scout (if available)
    if docker scout version > /dev/null 2>&1; then
        log_info "Running Docker Scout scan..."
        docker scout cves "$CONTAINER_IMAGE" --format sarif --output "$OUTPUT_DIR/docker-scout.sarif" > /dev/null 2>&1 || true
        docker scout cves "$CONTAINER_IMAGE" > "$OUTPUT_DIR/docker-scout.txt" 2>/dev/null || true
    fi
    
    log_success "Container scan completed"
}

# Function to scan infrastructure
scan_infrastructure() {
    log_scan "Starting infrastructure security scan..."
    
    # Checkov (if available)
    if check_tool "checkov" "pip install checkov"; then
        log_info "Running Checkov infrastructure scan..."
        checkov -d . --framework terraform,kubernetes,dockerfile --output json --output-file-path "$OUTPUT_DIR/checkov-results.json" > /dev/null 2>&1 || true
        checkov -d . --framework terraform,kubernetes,dockerfile > "$OUTPUT_DIR/checkov-results.txt" 2>/dev/null || true
    fi
    
    # TFSec for Terraform (if available)
    if check_tool "tfsec" "brew install tfsec"; then
        log_info "Running TFSec Terraform scan..."
        tfsec --format json --out "$OUTPUT_DIR/tfsec-results.json" . > /dev/null 2>&1 || true
        tfsec --out "$OUTPUT_DIR/tfsec-results.txt" . > /dev/null 2>&1 || true
    fi
    
    # Kubesec for Kubernetes manifests (if available)
    if check_tool "kubesec" "curl -sSX GET 'https://github.com/controlplaneio/kubesec/releases/download/v2.11.4/kubesec_linux_amd64.tar.gz' | tar xzf -"; then
        log_info "Running Kubesec Kubernetes scan..."
        
        find k8s -name "*.yaml" -o -name "*.yml" | while read manifest; do
            echo "Scanning: $manifest" >> "$OUTPUT_DIR/kubesec-results.txt"
            kubesec scan "$manifest" >> "$OUTPUT_DIR/kubesec-results.txt" 2>/dev/null || true
            echo "---" >> "$OUTPUT_DIR/kubesec-results.txt"
        done
    fi
    
    # Manual infrastructure checks
    log_info "Running manual infrastructure security checks..."
    cat > "$OUTPUT_DIR/infrastructure-manual.txt" << 'EOF'
# Manual Infrastructure Security Checks

## Kubernetes Security Best Practices Check:

EOF
    
    # Check for common Kubernetes security issues
    find k8s -name "*.yaml" -o -name "*.yml" | while read manifest; do
        echo "Checking: $manifest" >> "$OUTPUT_DIR/infrastructure-manual.txt"
        
        # Check for privileged containers
        if grep -q "privileged.*true" "$manifest"; then
            echo "  ❌ Found privileged container" >> "$OUTPUT_DIR/infrastructure-manual.txt"
        fi
        
        # Check for runAsRoot
        if grep -q "runAsUser.*0" "$manifest"; then
            echo "  ❌ Found container running as root" >> "$OUTPUT_DIR/infrastructure-manual.txt"
        fi
        
        # Check for missing resource limits
        if ! grep -q "limits:" "$manifest"; then
            echo "  ⚠️  Missing resource limits" >> "$OUTPUT_DIR/infrastructure-manual.txt"
        fi
        
        # Check for missing security context
        if ! grep -q "securityContext:" "$manifest"; then
            echo "  ⚠️  Missing security context" >> "$OUTPUT_DIR/infrastructure-manual.txt"
        fi
        
        echo "" >> "$OUTPUT_DIR/infrastructure-manual.txt"
    done
    
    log_success "Infrastructure scan completed"
}

# Function to generate security report
generate_report() {
    log_info "Generating comprehensive security report..."
    
    local report_file="$OUTPUT_DIR/security-report.md"
    local timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
    
    cat > "$report_file" << EOF
# 🔒 CoreFlow360 Security Scan Report

**Generated:** $timestamp  
**Scan Type:** $SCAN_TYPE  
**Repository:** $(git config --get remote.origin.url 2>/dev/null || echo "Local repository")  
**Commit:** $(git rev-parse HEAD 2>/dev/null || echo "Unknown")  
**Branch:** $(git branch --show-current 2>/dev/null || echo "Unknown")  

## 📊 Executive Summary

EOF
    
    # Count issues from different scans
    local total_issues=0
    local critical_issues=0
    local high_issues=0
    local medium_issues=0
    
    # Analyze npm audit results
    if [ -f "$OUTPUT_DIR/npm-audit.json" ]; then
        local npm_critical=$(jq -r '.vulnerabilities | to_entries[] | select(.value.severity == "critical") | .key' "$OUTPUT_DIR/npm-audit.json" 2>/dev/null | wc -l || echo "0")
        local npm_high=$(jq -r '.vulnerabilities | to_entries[] | select(.value.severity == "high") | .key' "$OUTPUT_DIR/npm-audit.json" 2>/dev/null | wc -l || echo "0")
        local npm_moderate=$(jq -r '.vulnerabilities | to_entries[] | select(.value.severity == "moderate") | .key' "$OUTPUT_DIR/npm-audit.json" 2>/dev/null | wc -l || echo "0")
        
        critical_issues=$((critical_issues + npm_critical))
        high_issues=$((high_issues + npm_high))
        medium_issues=$((medium_issues + npm_moderate))
    fi
    
    # Analyze Trivy results
    if [ -f "$OUTPUT_DIR/trivy-container.json" ]; then
        local trivy_critical=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL") | .VulnerabilityID' "$OUTPUT_DIR/trivy-container.json" 2>/dev/null | wc -l || echo "0")
        local trivy_high=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH") | .VulnerabilityID' "$OUTPUT_DIR/trivy-container.json" 2>/dev/null | wc -l || echo "0")
        local trivy_medium=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM") | .VulnerabilityID' "$OUTPUT_DIR/trivy-container.json" 2>/dev/null | wc -l || echo "0")
        
        critical_issues=$((critical_issues + trivy_critical))
        high_issues=$((high_issues + trivy_high))
        medium_issues=$((medium_issues + trivy_medium))
    fi
    
    total_issues=$((critical_issues + high_issues + medium_issues))
    
    cat >> "$report_file" << EOF
| Severity | Count | Status |
|----------|-------|--------|
| Critical | $critical_issues | $([ $critical_issues -eq 0 ] && echo "✅" || echo "❌") |
| High | $high_issues | $([ $high_issues -eq 0 ] && echo "✅" || echo "⚠️") |
| Medium | $medium_issues | $([ $medium_issues -eq 0 ] && echo "✅" || echo "⚠️") |
| **Total** | **$total_issues** | $([ $total_issues -eq 0 ] && echo "✅ Clean" || echo "⚠️ Needs Attention") |

## 🎯 Priority Actions

EOF
    
    if [ $critical_issues -gt 0 ]; then
        echo "### 🚨 Critical Issues (Fix Immediately)" >> "$report_file"
        echo "- $critical_issues critical vulnerabilities found" >> "$report_file"
        echo "- Review container and dependency scan results" >> "$report_file"
        echo "" >> "$report_file"
    fi
    
    if [ $high_issues -gt 0 ]; then
        echo "### ⚠️ High Priority Issues (Fix Within 24 Hours)" >> "$report_file"
        echo "- $high_issues high severity vulnerabilities found" >> "$report_file"
        echo "- Update dependencies and base images" >> "$report_file"
        echo "" >> "$report_file"
    fi
    
    cat >> "$report_file" << EOF
## 📋 Scan Details

### 🔍 Scans Performed
- [x] Dependency vulnerability scan
- [x] Secret detection scan
- [x] Container security scan
- [x] Infrastructure security scan
- [x] Manual security checks

### 📁 Available Reports
EOF
    
    # List available report files
    for file in "$OUTPUT_DIR"/*.{json,txt,sarif} 2>/dev/null; do
        if [ -f "$file" ]; then
            echo "- \`$(basename "$file")\`" >> "$report_file"
        fi
    done
    
    cat >> "$report_file" << EOF

## 🔧 Recommendations

### Immediate Actions
- Review and fix all critical and high severity vulnerabilities
- Update dependencies to latest secure versions
- Ensure no secrets are hardcoded in the repository

### Security Enhancements
- Implement automated security scanning in CI/CD
- Set up security monitoring and alerting
- Regular security reviews and penetration testing
- Security training for development team

### Best Practices
- Use dependency scanning tools (Snyk, npm audit)
- Implement secrets management (AWS Secrets Manager, HashiCorp Vault)
- Container security with minimal base images
- Infrastructure as Code security scanning

---
*Generated by CoreFlow360 Security Scanner v2.0*
EOF
    
    log_success "Security report generated: $report_file"
    
    # Display summary
    echo ""
    echo "🔒 SECURITY SCAN SUMMARY"
    echo "========================"
    echo "Total Issues: $total_issues"
    echo "Critical: $critical_issues"
    echo "High: $high_issues"
    echo "Medium: $medium_issues"
    echo ""
    echo "📁 Reports saved to: $OUTPUT_DIR"
    echo "📄 Main report: $report_file"
    echo ""
    
    # Return non-zero if there are critical/high issues and FAIL_ON_HIGH is true
    if [ "$FAIL_ON_HIGH" = "true" ] && [ $((critical_issues + high_issues)) -gt 0 ]; then
        log_error "Security scan failed due to critical/high severity vulnerabilities"
        return 1
    fi
    
    return 0
}

# Function to display usage
usage() {
    cat << EOF
CoreFlow360 Vulnerability Scanner

Usage: $0 [SCAN_TYPE] [OPTIONS]

Scan Types:
    all             Run all security scans (default)
    dependencies    Scan dependencies for vulnerabilities
    secrets         Scan for hardcoded secrets
    containers      Scan container images for vulnerabilities
    infrastructure  Scan infrastructure configurations

Options:
    --output-dir DIR        Output directory for reports (default: ./security-reports)
    --container-image IMAGE Container image to scan (default: coreflow360/consciousness:latest)
    --fail-on-high         Fail if high/critical vulnerabilities found (default: true)
    --verbose              Enable verbose output
    --help                 Show this help message

Environment Variables:
    OUTPUT_DIR             Output directory for reports
    CONTAINER_IMAGE        Container image to scan
    FAIL_ON_HIGH           Fail on high/critical issues (true/false)
    VERBOSE                Enable verbose output (true/false)

Examples:
    $0                                    # Run all scans
    $0 dependencies                       # Only scan dependencies
    $0 containers --container-image myapp # Scan specific container
    $0 all --output-dir /tmp/security     # Custom output directory

EOF
}

# Main function
main() {
    case "${1:-all}" in
        "dependencies")
            setup_output_dir
            scan_dependencies
            generate_report
            ;;
        "secrets")
            setup_output_dir
            scan_secrets
            generate_report
            ;;
        "containers")
            setup_output_dir
            scan_containers
            generate_report
            ;;
        "infrastructure")
            setup_output_dir
            scan_infrastructure
            generate_report
            ;;
        "all")
            setup_output_dir
            scan_dependencies
            scan_secrets
            scan_containers
            scan_infrastructure
            generate_report
            ;;
        "help"|"-h"|"--help")
            usage
            ;;
        *)
            log_error "Unknown scan type: $1"
            usage
            exit 1
            ;;
    esac
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --output-dir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --container-image)
            CONTAINER_IMAGE="$2"
            shift 2
            ;;
        --fail-on-high)
            FAIL_ON_HIGH="true"
            shift
            ;;
        --no-fail-on-high)
            FAIL_ON_HIGH="false"
            shift
            ;;
        --verbose)
            VERBOSE="true"
            shift
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        -*)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            SCAN_TYPE="$1"
            shift
            ;;
    esac
done

# Run main function
main "$SCAN_TYPE"